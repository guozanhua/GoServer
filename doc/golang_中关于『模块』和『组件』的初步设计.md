###golang 中关于『模块』和『组件』的初步设计###

「模块」和「组件」的概念来自于实际编码过程中产生的想法。

最先产生的是模块，它存在与这样一个环境之中：程序存在一个主进程，这个主进程负责程序在运行期的组建工作，它通过加/卸载不同的模块和组件，让程序呈现出不同的自身状态，以及提供不同的服务，或者同种服务中一些细节的差别（像不像操作系统？完全可以借鉴其思想）

模块的特点，或者它与组件的不同之处，在于它是独立与主进程，可自己运行的一个服务进程，它需要提供给主进程一个加载和挂载的接口。

在代码实现上，我将它们合并实现为 Module 接口，通过 IsSelfRun() 的返回值来判断对象是『模块』还是『组件』，为 true 即是模块。当它是组件时，则把 Breath() 加入到主进程的 Breath()(假设……不对，是主进程必然实现了Breath)中。

	type Module interface{
		Init()
		Breath()
		Run()
		Stop()
		
		IsSelfRun() bool
		
		// 便携
API
		Load() error
		Unload() error
	}
	 
从代码实现上来说，Load() 它实际上调用了 Init() 和 Run()（如果是模块的话），Unload() 实际调用了 Stop()。所以，也许并不需要这么多接口，但我是这样以为的，从程序员的角度来说，Init Run Stop 这些关键字浅显易懂，加上也还行。而 Load Unload 是从接口使用者的角度出发的，所以是必须存在的。这样的设计或许缺点就是冗余，并且对某些人会产生困扰，该不该还是看实际应用吧。

还需要克服的一个问题是，单个模块和组件之间相互调用和通信的手段和实现。可以使用的方法有，系统层提供的共享内存，通信管道等；利用主进程，实现类似的消息通讯，共享内存的机制。这些暂时没有接口的设计和实现。                                            

#### 模块/组件的生成以及使用 ####
定义问题域，主要用来测试：
1、初始化时候，能根据命令行，读入指定配置文件；
2、读入用户输入；
	1、启动模块
	2、关闭模块
3、能够一边跑Breath，一边处理用户输入；
4、能保持一连串的模块；
	1、暂不做模块状态的处理